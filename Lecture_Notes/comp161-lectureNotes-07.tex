\documentclass[]{tufte-handout}
\usepackage{amsmath,amssymb,amsthm,color}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[pdftex]{graphicx}
\usepackage{framed}

  
\title{COMP 161 - Lecture Notes - 07 - Procedures for Effect: I/O and State}


\begin{document} 
\maketitle

\begin{abstract}
In these notes we look at effects. We'll discuss how they might arise in through program design and consider recipes for designing and developing effect-based procedures.
\end{abstract}

\section{Interactive Testing}

So far, you've only interacted with your functions by writing and running tests. While having frameworks like gTest are great. It's also really nice to interact with the code yourself. If we put this in the context of testing, it'd be nice to be able to choose an input on the fly, feed that to the function, and see the result. We want to interact with the code in a dynamic fashion. This can be an important part of debugging and problem solving, so we should learn how to do it. It also turns out that the programming tools we need to do interactive testing are the same tools we need to write interactive programs. So, while we're just going to think about the problem of testing functions. You should be imagining how these new tools lead to the kind of interactive functionality we know of love form computers. 

\subsection{The Function}

Let's look at problem 1 from section 4 of the HTDP1e online problem set\sidenote{\url{http://htdp.org/2003-09-26/Problems/4.html}}. I've renamed the function to conform with our C++ standards rather than BSL standards. 

\begin{framed}
\begin{quote}
Develop the function \textit{isWithin}, which consumes three numbers representing the $x$ and $y$ coordinates of a point and the radius $r$ of a circle centered around the origin It returns true if the point is within or on the circle. It returns false otherwise. The distance of the point to the origin is the square root of $x^2 + y^2$.
\end{quote}
\end{framed}

Here's the end product of our development process\sidenote{Recreate this process for practice}
\begin{verbatim}
// In the header

namespace TwoD{
  
  
  /**
   * Determine if the point (x,y) is on or within a 
   * circle with center (0,0) and radius r
   * @param x the x coordinate of the point
   * @param y the y coordinate of the point
   * @param r the radius of the circle
   * @return true if (x,y) is in or within the circle
   * @pre radius r is positive or 0
   */
  bool isWithin(double x, double y, double r);

}

// In the tests

TEST(isWithin,all){
  using namespace TwoD;
  
  // Positive Tests 
  EXPECT_TRUE(isWithin(0,0,0));
  EXPECT_TRUE(isWithin(0,0,0.5));
  EXPECT_TRUE(isWithin(0,0,2.5));
  EXPECT_TRUE(isWithin(1.0,0.5,2.5));   
  EXPECT_TRUE(isWithin(2.5,0.0,2.5));
  EXPECT_TRUE(isWithin(0.0,2.5,2.5));
	  
  // Negative Tests
  EXPECT_FALSE(isWithin(1.0,0,0));
  EXPECT_FALSE(isWithin(0,1.0,0.5));
  EXPECT_FALSE(isWithin(2.5,2.5,2.5));
  EXPECT_FALSE(isWithin(0,0.501,0.5));   
  EXPECT_FALSE(isWithin(2.5,0.1,2.5));
  EXPECT_FALSE(isWithin(0.0,3.0,2.5));
  
}

// In the Library Implementation

#include <cmath>

namespace TwoD{

  bool isWithin(double x, double y, double r){
     return r >= sqrt(x*x + y*y);
  }

}
\end{verbatim}

With this kind of function we can expect to run into some double arithmetic rounding problems. In particular, when we're checking for the point one the edge of the circle, the equality case, things could easily get off and produce erroneous results. So, it might be nice to interactively test this function to see when that kind of problem crops up. It might also be nice to try some new values without the need to write new tests. 


\section{Goal: Two Programs for Interactive Testing}

Let's identify two programs that would allow us to test \textit{isWithin} in an interactive fashion:
\begin{enumerate}
\item an primative REPL\sidenote{Read Evaluate Print Loop} program that prompts you for input values and prints the results until you close it. The looping part is really optional. We could just do one test, then relaunch the program for more tests as needed.
\item a CLI program that lets the user pass the \textit{isWithin} inputs as CLI arguments. This is like the previous program without a loop and without any prompts. 
\end{enumerate}

We'll first focus on program number one, the REPL program. It's a bit easier to get off the ground and exposes to wide and wonderful world of effect-based, imperative, procedural programming. We'll also checkout program number two, but will likely hand-wave over a few details that we'll explore in depth later on down the line.

\subsection{Problem: Effects}

Before we dive into the guts of these programs, let's make it clear why we need effect-based code. Clearly we need \textsc{I/O}\sidenote{Input/Output} effects as we must \textsc{read} data from the CLI input, aka \textsc{stdin} and feed it as inputs to our function.  We then want to \textsc{write} the results of our computation to the CLI output, \textsc{stdout}.  Racket did this kind of thing implicitly in the interactions window. We have no such system now and need to explicitly manage it ourselves. 

What's less clear is why we need \textsc{state mutation}. The short answer is because you cannot read from stdin directly into a function. You must first read into a variable\sidenote{i.e. memory}, then pass the value of that variable to the function.  This means declaring and initializing a variable, then using \textsc{mutation} to change the value to what is read from stdin. There are good reasons for this requirement. Sometimes the read fails. If that happens when you're attempting to call the function, then your program will probably crash. It's also just a bad idea to assume that what's coming in from \textit{stdin}, or input devices in general, is well-formed, valid data. You might be expecting a number, but the user could, for whatever reason, give you string data. This can be an honest mistake or malicious intent. In web-based systems, you want to check all user input from a form before acting on it in order to avoid SQL injection\sidenote{\url{http://en.wikipedia.org/wiki/SQL_injection}}. 

When dealing with CLI arguments as we'll do with program two, we don't have to worry about reading from stdin. The operating system takes the CLI command, parses it, and sends it to our program as C strings.  This is great if we needed strings, but we need numbers. The solution is actually to use a C++ library that allows us to treat a string as a input device. We can then read from the string(s) in the exact way we read from the CLI. The end result is the same, we just have to work through an intermediate step. 

\section{Program 1: Interactive REPL}

Let's dive right into the first program. We'll first look at the whole main procedure, then we'll break down the logical steps. I've included the \textit{\#include} statements to highlight the standard C++ I/O library, \textit{iostream}\sidenote{\url{http://www.cplusplus.com/reference/iostream/}}. 

\begin{verbatim}

#include <iostream> //std::cout std::cin std::boolalpha
#include "ln7.h"    // TwoD::isWithin

int main(int argc, char* argv[]){
  using namespace TwoD;
  using namespace std;

  // Declare Variables to hold user input
  double x{0.0};
  double y{0.0};
  double r{0.0};

  // explicit infinite loop
  // Use Ctrl-C to kill the program at the CLI
  // This is a terrible idea more often than not, but
  // works for this application.
  while(true){
     
    // Prompt and get x,y
    cout << "Enter point coordinates: ";
    cin >> x >> y;
    // Prompt and get r
    cout << "Enter circle radius: ";
    cin >> r;
    
    // Compute and report results
    cout << "isWithin( " << x <<" , " << y << " , " << r << " ) -> " <<
      boolalpha << isWithin(x,y,r) << '\n';
      
  } //end while

  return 0;
}
\end{verbatim}

The first two lines of the procedure are the familiar \textit{using namespace} statements. The first namespace is for \textit{isWithin}. The later, \textit{std}, is the \textit{standard} namespace that contains all the elements of the \textit{iostream} library. 


\subsection{Variable Declaration and Initialization}

The first step of the procedure is to declare and initialize variables for our user input. 
\begin{verbatim}
// Declare Variables to hold user input
double x{0.0};
double y{0.0};
double r{0.0};
\end{verbatim}

Here we see three variable of type double, \textit{x}, \textit{y}, and \textit{r}, each assigned an initial value of $0.0$ using brace-initialization. This form of initialization is new to the c++11 standard\sidenote{this means we need to add the -std=c++11 compiler option to the Makefile rule for building objects}. Prior to the c++11 standard you'd see alternative initialization statements such as:
\begin{verbatim}
double y; //pure variable declaration. type and name
y = 0.0; // then immediately assign "initial" value

double x = 0.0; //declare and initialize with assignment

double r(0.0); //constructor function style with parenthesis
\end{verbatim}

The first option is really a C style. It's only an initialization in that nothing happens between declaration and the assignment. I don't prefer this because you're tempted to not assign an initial value and you should always assign an initial value. The second line of this pair bears some comment. This is a \textsc{state mutation} or \textit{variable assignment} statement. It is not a mathematical equation. It is a statement that reads: ``Assign the value 0.0 to the variable with name y'' or ``Assign the value 0.0 to the memory location labeled with the name y''. We'll talk in more detail about assignment shortly.

The second option for initialization is nice because it's one cohesive statement, but because it uses the assignment operator $=$ it can sometimes confuse people about the usage of variable type annotation. They see the \textit{double} in this statement and want to then continue to use double wherever they are referring to, and specifically assigning values to, \textit{x}.  I prefer my initialization statements to look completely different from my general purpose assignment statements.

The final option is great from the perspective that it looks different than assignment and therefore reminds us that initialization and general purpose assignment are different things. The only reason we'll use braces instead of parenthesis is that the parenthesis become more meaningful as we explore more involved kinds of data.  Curly brace initialization was introduced to provide a consistent means of initializing data for standard C++ types. 

We'll always use the new brace initialization style as it really sets apart initialization and is fairly uniform across the types of data we'll use. You should recognize other initialization styles because you may need to read or write them someday, but \textit{always initialize and always use brace initialization in this class}\sidenote{second reminder: this requires the compiler option -std=c++11}.

\subsection{Infinite Loop}

Next you're confronted with an infinite loop, specifically an infinite \textit{while} loop. 
\begin{verbatim}
while(true){
  // Loop body
}
\end{verbatim}
A \textit{while} loop will repeat everything in it's curly brace block\sidenote{called the loop body} for as long as the boolean expression in the parenthesis evaluates to \textit{true}\sidenote{If you can't wait to learn more: \url{http://www.cplusplus.com/doc/tutorial/control/}}. In this case, we've explicitly put \textit{true} in parenthesis so this loop will repeat forever. We'll explore loops quite a bit soon, but it's really hard to separate loops constructs like this one from effects. A great many loops drive variable mutation over time or I/O like this one. In short, a loop is rarely, if ever, a functional, black-box process; they almost always have some kind of effect on the overall system with respect to your program.  

There aren't a lot of good reasons to write infinite loops. This one makes sense from the perspective that we're writing a program only meant to be run by us and with a very special purpose. It's a quick and dirty solution to the problem of creating a REPL and we're not imagining this program will have much of a life span or user base. As soon as your program is going to be around awhile or used by people not you, you should find a better way than an infinite loop\sidenote{Like an explicit quit key}Be warned, I'll rarely expect an explicitly infinite loop as a solution to a problem on your homework. 

\subsection{Prompt and Input Sequences}

The body of our infinite loop contains our first I/O statements. What we see is a pattern of prompting the user for input then actually getting their input. Let's look at the first example. 
\begin{verbatim}
cout << "Enter point coordinates: ";
cin >> x >> y;
\end{verbatim}

We want to think of these statements in terms of the binary \textsc{streaming output operator} $<<$\sidenote{``put to'' operator} and the binary \textsc{streaming input operator} $>>$\sidenote{``get from''}. Let's start with the first statement-- the output statement. To the left of the operator is the output stream \textit{cout}\sidenote{or std::cout because it's in the \textit{std} namespace}. It is our direct connection to the CLI standard output. The effect of this statement is to print the string literal ``Enter point coordinates: ''. 

The input stream \textit{cin} connects us to \textit{stdin}. It reads values from the CLI and, in this case, writes them to variables. Data from \textit{cin} is, by default, separated by white space. In this case, we'll take the first \textsc{token} and read it like a double, because \textit{x} is a double, and save it to \textit{x}. The next token is also read as a double and then saved to \textit{y}. You can separate the two tokens with spaces, tabs, or even newlines as those all qualify as whitespace characters. It's important to note that the program will ready \textit{any} data as if it were a double.  If you type the string \textit{hello}, the program will attempt to interpret as a double literal and interesting and unexpected things will happen. 


Our procedure continues with one more prompt and input sequence:
\begin{verbatim}
cout << "Enter circle radius: ";
cin >> r;
\end{verbatim}
Let's just restate the effect of these statements in plain English:
\begin{quote}
Put the string literal ``Enter circle radius: '' to the standard output via the stream \textit{cout} get a value from the standard input stream \textit{cin} and write it as a double to the variable $r$.
\end{quote}
It's important to get a feel reading these statements as applications of streaming I/O operators. In doing so you'll be less attached to specific streams and more able to adapt this logic to alternate I/O streams.

There is a great deal of effect-based programming going on under the hood of the streaming I/O objects \textit{cin} and \textit{cout}. We'll expose some details as needed. For now, it's enough to know that that they buffer\sidenote{temporarily store} data from their receptive devices and that the I/O operators mutate the contents of those buffers when you use them. They are your first example of \textsc{stateful objects}. They are not black-boxes. They have hidden internal state that combines with input to determine their output and behavior.

\subsection{More Involved Output}

The last statement in out loop is a fairly involved output statement.
\begin{verbatim}
cout << "isWithin( " << x <<" , " << y << " , " << r << " ) -> " <<
      boolalpha << isWithin(x,y,r) << '\n'; 
\end{verbatim}

First note that this is a long statement and I split it across two lines. The compiler typically treats all white space the same and generally ignores it. This means we're free to split a line as long as we don't break up something important.\sidenote{Don't split the string literal or a $<<$}. To understand why we have a lot of $<<$ operators in this statement remember that the operator is binary only with one operand being the stream and the other a single datum. So, in order to output $n$ things, we'll need $n$ operators. 


Before going further, let's see an example of the kind of output this produces:
\begin{verbatim}
isWithin( 3.4 , 5.6 , 10 ) -> true
\end{verbatim}
All of the spacing in that output \textit{is not the result of breaking things up with $<<$}. Put another way, \textit{additional $<<$ operators do not introduce any kind of white space to the output.}  If you go back and look at all the string values, you'll notice carefully placed spaces. This is how the actual output comes out nice and readable. Without those spaces it would all be smashed together.

We could also get the exact same output with two statements instead of just the one.
\begin{verbatim}
cout << "isWithin( " << x <<" , " << y << " , " << r << " ) -> ";
cout <<  boolalpha << isWithin(x,y,r) << '\n'; 
\end{verbatim}
This alternative sequence of output statements tells us that \textit{new output statements do not produce new lines in the output}. 

Students first starting out with C++ I/O assume too much of their operators. So, commit this thought to memory now:
\begin{quote}
If you want spaces and newlines in your output, then you must explicitly put it there.
\end{quote}


There is one final thing of note in this statement. One of the tokens is not actual output, but a token used to modify how data in the stream following it is displayed. Any boolean values after the \textit{boolalpha}\sidenote{std::boolalpha} token will be printed as \textit{true} or \textit{false} rather than $1$ or $0$.  We call these tokens \textsc{I/O manipulators}. They are used to set the state of the I/O stream object and modify the way in which data is displayed.  They allow us to format how data is displayed. 

Before moving on, let's restate this dozy of an output statement in plain English:
\begin{quote}
The the stream \textit{cout} put the following data, in this order: the string literal ``isWithin( '' the value stored in the variable x, the string `` , '', the value stored in y, the string `` , '', the value stored in r, and the string `` ) -> ''. Next, put the boolalpha manipulator to the cout stream in order to format boolean output to alphabetic. Finally, put the result of \textit{isWithin(x,y,r)} to cout and the newline character. 
\end{quote}

\subsection{Recap}

This relatively straight forward example illustrates several key issues surround basic C++ stream I/O and variables.  Be sure you understand what's happening with this concrete example. In the following sections we'll explore the big picture and establish some general guidelines for variable and I/O effects.

\section{State Variables}

We previously encountered variables when dealing with the linux CLI and noted that three logical operations tend to govern our interaction with variables.
\begin{itemize}
\item \textsc{Initialization} \\
Assigning a starting, initial value to the variable.
\item \textsc{Mutation} \\
Assigning a new value to a previously initialized variable
\item \textsc{Access} \\
Viewing or getting the current value in the variable.
\end{itemize}
Let's look at basic statements for each of these operations.

\subsection{Declaration and Initialization}

In C++, variables are typed. This means they can only hold values of that type. When we first add, or \textit{declare}, a variable to our program we must state its type and name and initialize its value. Variable declarations simply provide the type and the name with no initial value-- \textit{you should never just declare a variable}. We'll be using the C++11 brace initialization syntax and so our variable declarations and initializations have the following template:
\begin{verbatim}
TYPE NAME{INITIAL-VALUE};
\end{verbatim}

You've seen a few examples already, but here's a few more:
\begin{verbatim}
char achar{'a'};
bool isOK{false};
int  size{15};
double amplitude{0.707};
\end{verbatim}

\subsection{Accessing Variables}

When we talk about accessing a variable we mean retrieving the value currently stored in that variable. To do this we simply refer to the variable by name. You saw this in the output statements from our testing program and when we called the function.  Here's a few more examples of accessing variables.  I've reused the variables from above and written examples of accessing them in the context of gTest unit tests so that you get a sense for the substitution of variable name for value.

\begin{verbatim}
EXPECT_EQ('a',achar);
EXPECT_EQ('A',toupper(achar));

EXPECT_FALSE(isOK);
EXPECT_TRUE(!isOK);
EXPECT_TRUE(isOK || !isOK);

EXPECT_EQ(15,size);
EXPECT_EQ(-3,size-18);
EXPECT_EQ(33,2*size+3);

EXPECT_DOUBLE_EQ(0.707,amplitude);
EXPECT_DOUBLE_EQ(1.414,2*amplitude);
\end{verbatim}


\subsection{Variable Mutation}

To mutate a variable means to assign it a new value. This is carried out via the assignment operator $=$. This operator is binary. Its left-hand operand must be something with an associated location\sidenote{\textsc{l-value}}, i.e. the name of a variable. Its  right-hand operand must be an expression, i.e. something with an associated value\sidenote{\textsc{r-value}}. Let's look at a few examples and then break them down.
\begin{verbatim}
size = 5;
achar = toupper('R');
size = size + 5;
achar = toupper(achar);
\end{verbatim}

The first example is straight forward: ``Assign the value 5 to the variable \textit{size}''.  The second example assigns the return result of \textit{toupper('R')} to the variable achar. The next example looks nuts if you confuse assignment $=$ with how we read $=$ in mathematics. As a C++ assignment statement it reads: ``Assign the value of size+5 back to size''.  If the current value in size is 10, then it changes to 15 as a result of this statement.  If we read this statement like mathematics then it says: ``size is the same as itself plus 5''. That's nuts. No number is equal to five plus itself.  The final assignment example is like the second in that we're first computing the toupper of the current value in achar, then assigning that back to achar.

Assigning a variable an updated value based on its current value is so common that several shortcut operators exist for just this purpose.
\begin{center}
\begin{tabular}{rl}
Operator & purpose \\ \hline
$+=$ & $a+=b$ is the same as $a = a + b$ \\
$*=$ & like $+=$ but with $*$ \\
$-=$ & like $+=$ but with $-$ \\
$/=$ & like $+=$ but with $/$ 
\end{tabular}
\end{center}

\section{Streaming I/O}

The C++ streaming I/O system provides a fairly uniform way of approaching I/O tasks. Streams provide buffered I/O access to a device and the operators $<<$ and $>>$ are used to put and get, respectively, data from those streams. Our testing REPL exposed us to the standard output stream \textit{cout} and the standard input stream \textit{cin}. The \textit{iostream} library also provides the output stream \textit{cerr}, which is the standard error output. The \textit{fstream} library allows us to create I/O streams for files. The \textit{stringstream} library allows us to treat string objects like streaming I/O devices and in doing so lets us leverage the streaming I/O capabilities for interpreting characters as typed data, and vice versa, when processing string data. Our first use for this will be working with arguments passed to our programs form the command line.

The following examples will all use \textit{cout} and \textit{cin} as our representative stream objects. Later we'll see that we can replace \textit{cout} with another output stream object and \textit{cin} with an input stream object and get the same general results, just to different I/O devices.

\subsection{Streaming Output}

As we've seen already, streaming output is done via the ``put to'' operator \textit{$<<$}. Our example program really highlights all the key issues for working with streaming output, so it bears close examination. The main things to remember are that:
\begin{itemize}
\item the only white space that gets written is the white space you explicitly add to the stream
\item you chain together multiple uses of $<<$ with a single stream as long as its one datum per operator
\end{itemize}
To illustrate these points I give you one example. 
\begin{verbatim}
cout << 7 << 8.36 << " isn't ";
cout << 7 << " " << 8.36 << "\n" << "hi\n";
\end{verbatim}
The result of these two statements is the output:
\begin{verbatim}
78.36 isn't 7 8.36
hi

\end{verbatim}
The cursor ends immediately below the h in hi. 

\subsection{Streaming Input}

Once again, our example problem pretty much covers all the bases. Go back and read it carefully. 
\begin{itemize}
\item You cannot do streaming input without variables because you must have a place to store the value that $>>$ gets from the stream
\item Data from the stream is broken up by whitespace. This includes the enter key, so hitting enter doesn't terminate input, reading tokens does.
\item The way in which data is read from the stream is determined by the type of the variable in which the data is being stored and not by how it appears in the stream. 
\item You can chain input together to read multiple values with a single statement.
\end{itemize}

\section{Program 2: CLI Input}

The CLI is built of string data.  When we want to take input from the CLI for our C++ programs, then we have to take it as strings.  So, to get our second program working, we need to start looking at strings. We'll start with a quick and dirty overview of just some essentials for managing this program and get into more details in lectures down the line.

Without further ado, here's a version of this program that lets you pass in your test values from the CLI. The tradeoff here is that there is no loop. We have to re-run this for each new set of data\sidenote{or write a looping Bash program to run this maybe}.
\begin{verbatim}
#include <iostream>
#include <sstream>
#include "ln7.h"

int main(int argc, char* argv[]){
  using namespace TwoD;
  using namespace std;

  double x{0.0};
  double y{0.0};
  double r{0.0};

  // Quick error check for enough arguments
  if( argc != 4 ){
    cerr << "Not enough arguments. Usage: " << argv[0] << " x y r\n";
    return 1;
  }

  // Let's assume we typed numbers as arguments
  istringstream xstream(argv[1]);
  xstream >> x;

  istringstream ystream(argv[2]);
  ystream >> y;

  istringstream rstream(argv[3]);
  rstream >> r;


  cout << "isWithin( " << x <<" , " << y << " , " << r << " ) -> " <<
    std::boolalpha << isWithin(x,y,r) << '\n';


  return 0;
}

\end{verbatim}

\subsection{CLI Inputs and \textit{main}'s arguments}

\subsection{Streaming Strings}

\section{This Doesn't Scale Well}
\end{document}