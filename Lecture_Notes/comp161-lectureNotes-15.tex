\documentclass[]{tufte-handout}
\usepackage{amsmath,amssymb,amsthm,color}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{framed}
\usepackage[pdftex]{graphicx}


\title{COMP 161 - Lecture Notes - 15 - make and Makefiles}
\date{Spring 2014}

\begin{document} 
\maketitle

\begin{abstract}
In these notes we stop a moment to look at the program \textit{make} and how it can be used to automate parts of the program build process. These notes are all adapted from the GNU \textit{make} manual; you should read the introductory material there\sidenote{\url{http://www.gnu.org/software/make/manual/make.html}}
\end{abstract}

\section{Why make?}

Let's consider a basic program using our standard structure: \textit{main\_prog.cpp} contains the main procedure and utilizes three libraries \textit{lib1, lib2,} and \textit{lib3}. Each library has it implementation \textit{cpp} file, its header \textit{h} file, and another \textit{cpp} file containing gTest tests.  We might imagine the following build tasks:
\begin{itemize}
\item Compile and link the libraries with the main file
\item Compile and link the libraries with the tests and the gTest main 
\item Compile and link one library with gTest
\item Compile any of the \textit{cpp} files to an object
\end{itemize}
The first few options require compiling many files when changes may only have been made to a one or two of those files.  If you forget to compile one and use an old object, then you might see bugs where there are none. Wouldn't it be nice if the system just knew to recompile any library that has been changed? Well, \textit{make} can do this.  Using \textit{make} also saves you from having to type long compile commands or from search back though your command history to find the right command.  

In practice, programs can require significantly more source files than we're used to\sidenote{Go explore the source for the game DOOM 3 \url{https://github.com/id-Software/DOOM-3}}.  All of the compiling tasks that are annoyances with our small projects are nearly intractable problems with large software projects. Keeping track of dependencies between files in large programs is really a task best left to a program.  This is what \textit{make} and programs like \textit{make} can do for us. The \textit{make} program can save time and frustration.  It's not hard to use and there is a wealth of information on the web.  In these notes we'll look some basics and see how to use \textit{make} for all those build tasks we talked about. 

\section{Basic make}

When all you want to do is compile a single file that does not need to be linked to any other file, then make can automatically determine a g++ command for you. Let's say you want to compile an object file from a \textit{lib1.cpp}.  Then all you need to do is pass \textit{make} the name of the file it should make, in this case \textit{lib1.o}.  

\begin{verbatim}
make lib1.o
\end{verbatim}

When you run this command make comes up with the following command:
\begin{verbatim}
g++    -c -o lib1.o lib1.cpp
\end{verbatim}
You should recognize this as the command for building \textit{lib1.o} from \textit{lib1.cpp}\sidenote{notice the arguments are given in a different order than we're used to}. 

Now what if you have a simple program that was entirely contained in a single source file \textit{simple.cpp} and you wanted to build the executable \textit{simple}?  You could use the following make command:
\begin{verbatim}
make simple
\end{verbatim}
This results in the follow compilation command:
\begin{verbatim}
g++     lib1.cpp   -o lib1
\end{verbatim}
This again, is a fairly standard \textit{g++} command for building executables.  

What we've seen is that without any significant intervention on our part, \textit{make} can manage some very basic compile time tasks. However, the commands it uses are perhaps too simple. What if we want the warnings given by \textit{-Wall}? What if we need to link multiple files together or link to a library like \textit{gTest}?  What if we want the name of the made file to differ from that of the dependencies?  For this we need to exert some control of what \textit{make} does, and for that we must provide make with a script telling it what kinds of commands to use.  This script is called a \textit{Makefile}

\section{Makefiles}

To control the behavior of \textit{make} you must create a file named \textit{Makefile} and place it in your current working directory. If such a file exists, then when \textit{make} is run it will look to that file for rules to use in making certain files.  Rules have a very simple form:
\begin{verbatim}
target : dependencies
     rules
     ...
\end{verbatim}
The \textit{target} is the file to be made. The \textit{dependencies} are the files needed to make the \textit{target}. Finally, the \textit{rules} are the commands used to turn the \textit{dependencies} in to the \textit{target}.  It is vital to note that the spacing before each rule \textbf{must be a tab}.  You can't use multiple spaces or anything other than a single instance of the tab character.

Let's start with some rules for building some library objects for our pretend project
\begin{verbatim}

lib1.o : lib1.cpp
     g++ lib1.cpp -c -Wall
     
lib2.o : lib2.cpp
     g++ lib2.cpp -c -Wall

lib3.o : lib3.cpp
     g++ lib3.cpp -c -Wall

\end{verbatim}
Now if you type \textit{make lib1.o}, then make will find your \textit{lib1.o} rule and use that rule. We've included the \textit{-Wall} flag in our rule, so now we get warning reports as well as errors.  

So far so good. Let's build some rules for making our test program.  In this case, we want to build all our test objects, then link them together into a single text executable. We can then use the gTest filters to run individual tests if we like. 
\begin{verbatim}

libTests : lib1_tests.o lib2_tests.o lib3_tests.o lib1.o lib2.o lib3.o
    g++ lib1_tests.o lib2_tests.o lib3_tests.o lib1.o lib2.o lib3.o \
-lgtest -lgtest_main -lpthread -o libTests

lib1_tests.o : lib1_tests.cpp
    g++ lib1_tests.cpp -c -Wall

lib2_tests.o : lib2_tests.cpp
    g++ lib2_tests.cpp -c -Wall

lib3_tests.o : lib3_tests.cpp
    g++ lib3_tests.cpp -c -Wall

\end{verbatim}
Here we used a backslash in a recipe line to break up the line so that it fits on a page when printed. You shouldn't run in to many problems with this, but splitting lines like this doesn't always work as intended\sidenote{\url{http://www.gnu.org/software/make/manual/make.html\#Splitting-Recipe-Lines}}.

If we combine the above rules with our previous rules for the library implementation objects, then we have everything we need to build our text executable.  Let's say that you've compiled nothing. Then the command \textit{make libTests} will first note that all the dependencies are missing and invoke the rule for each dependency automatically.  Thus, in one simple command, we'd invoke seven compile commands.  Now, what if you changed something in \textit{lib2.cpp}? You need to recompile \textit{lib2.o} and \textit{lib2\_tests.o}. You could run the make rules for each object, but re-running \textit{libTests} will cause \textit{make} to notice that \textit{lib2.cpp} has changed. This in turn will cause \textit{make} to rebuild those dependencies.  This is a killer feature of \textit{make}. It will, more often than not, keep your dependencies up to date. 

Let's finish things out with the rules needed to build our main executable.
\begin{verbatim}
myprog : main_prog.o lib1.o lib2.o lib3.o
    g++ main_prog.o lib1.o lib2.o lib3.o -o myprog

main_prog.o : main_prog.cpp
    g++ main_prog.cpp -c -Wall
\end{verbatim} 
With the addition of these rules we have everything we need to use \textit{make} in order to build all the various elements of our program.  What's more, if we place the \textit{myprog} rule at the top of the Makefile, then the command \textit{make} will automatically run that rule.  In general, \textit{make} runs the first rule in the Makefile.  If you wanted the test executable to be the default rule, then you'd place that first in the file and list all the other rules underneath it. 

\subsection{Phony Rules}

Thus far all of our Makefile rules have built specific files by name.  Sometimes we want logical rules, rules where the target isn't the name of a file but a description of a build or build related scenario.  Put another way, sometimes we like to name rules for what the do, not what they produce. Such rules are called \textit{phony} rules.

The classic phony rule is \textit{clean}.  The \textit{make clean} rule is included in most standard Makefiles and is used to get rid of everything but the source code files.  In our case this means deleting object files, emacs temporary files, and executables.  We'll use a series of phony rules for this, a rule for each file type, and then have \textit{make clean} call all the individual clean rules.  
\begin{verbatim}

.PHONY : clean cleanobj cleanexe cleantemp

clean : cleanobj cleanexe cleantemp

cleanobj : 
    rm *.o

cleanexe : 
    rm myprog libTests

cleantemp :
    rm *~
    
\end{verbatim}
First, notice that we By listing the sub-rules as dependencies for \textit{clean}, we ensure that \textit{make clean} invokes each of these rules.  The sub rules all have no dependencies and run a simple \textit{rm} command to get rid of some files.  We could have written a single clean rule like this:
\begin{verbatim}
.PHONY : clean

clean : 
     rm *.o *~ myprog libtests
\end{verbatim}
Writing sub-rules gives you the option to clear out specific groups of files if you want. It also illustrates that we can chain phony rules together the same way that concrete rules get chained together.

\newpage
\section{Complete Makefile}

\begin{verbatim}

myprog : main_prog.o lib1.o lib2.o lib3.o
    g++ main_prog.o lib1.o lib2.o lib3.o -o myprog

main_prog.o : main_prog.cpp
    g++ main_prog.cpp -c -Wall

libTests : lib1_tests.o lib2_tests.o lib3_tests.o lib1.o lib2.o lib3.o
    g++ lib1_tests.o lib2_tests.o lib3_tests.o lib1.o lib2.o lib3.o \
-lgtest -lgtest_main -lpthread -o libTests

lib1_tests.o : lib1_tests.cpp
    g++ lib1_tests.cpp -c -Wall

lib2_tests.o : lib2_tests.cpp
    g++ lib2_tests.cpp -c -Wall

lib3_tests.o : lib3_tests.cpp
    g++ lib3_tests.cpp -c -Wall

lib1.o : lib1.cpp
     g++ lib1.cpp -c -Wall
     
lib2.o : lib2.cpp
     g++ lib2.cpp -c -Wall

lib3.o : lib3.cpp
     g++ lib3.cpp -c -Wall

.PHONY : clean cleanobj cleanexe cleantemp

clean : cleanobj cleanexe cleantemp

cleanobj : 
    rm *.o

cleanexe : 
    rm myprog libTests

cleantemp :
    rm *~
\end{verbatim}

\end{document}