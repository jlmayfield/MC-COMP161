\documentclass[nobib]{tufte-handout}
\usepackage{amsmath,amssymb,amsthm,color,listings}
\usepackage[pdftex]{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

  
\title{COMP 161 - Lecture Notes - 10 - State and Functions}
\date{Spring 2016}

\begin{document} 
\maketitle

\begin{abstract}
We now step back and consider a complete program from start to finish. Along the way we'll see examples of problems that are succinctly captured with state and the use of functions vs mutators. 
\end{abstract}

\section{The Program}
% (This is just (curr + m) mod 21) with some other stuff thrown in

The program we'll consider is a simple interactive ``game'' that functions off a REPL interface. The game begins with the player on the first of 21 spots. Players choose some integer number of places to move. Their piece is then moved that many places. If while moving they go past the first or last spot, then their piece wraps around to the other side. The game tracks the number of times they wrap around. That's it. 

The interface for the game should show their piece as an X on a line as well as display their wrapped score. The use is then prompted for their move. The game then updates their location and score and the loop repeats. Figure \ref{fig:example} shows what that would look like for a short game. 

\begin{figure}[!htbp]
\begin{verbatim}
|X--------------------|
wrapped: 0 

move? 3

|---X-----------------|
wrapped: 0 

move? -7

|----------------X----|
wrapped: 1 

move? 15

|----------X----------|
wrapped: 2 

move?  50

|------------------X--|
wrapped: 4 

move ?
\end{verbatim}
\label{fig:example}
\caption{A Short, Four move game}
\end{figure}

\section{A Problem of State}

This problem clearly involves state. At any given time we must know two things: the player's location and the number of times they've wrapped around. It makes sense to look at these these things as values that change \textit{over time}. Anytime you fix your logic on how a piece of information changes over time, then you're looking at a situation where state is an obvious choice. The information is represented by a variable and the change is carried out through mutation. Our experience with mutation and state thus far as been largely confined to uses state to solve problems. Now we see that some problems are naturally expressed in terms of state. 

At this point can start stubbing out a bit of \textit{main} to capture what we know about our program as C++. In doing so we  transliterate high-level, abstract information and design to concrete code.  So what do we know? We know that the game operates with a basic REPL design and as it loops it works with two state variables. In figure \ref{fig:mainstub1} we see these ideas as C++.
 
\begin{figure}[!htbp]
\begin{lstlisting}

int main( int argc, char* argv[] ){

	// Program State Variables
	int cur_loc{0}; // player location
	int num_wrap{0}; // number of times player wrapped
	
	while( true ){
	
		// ... cur_loc ...
	 	// ... num_wrap ...
	}

	return 0;
}

\end{lstlisting}
\caption{A quick, initial sketch for \textit{main}}
\label{fig:mainstub1}
\end{figure}

\section{Wish Lists and Top-Down Design}

Now that we have a very basic starting place, we can begin the process of generating a wish list of procedures that can be used to complete the problem. Notice we do not start completing the program. This procedural design so we start by finding procedures. We also want to give ourselves some options for each part of the program. We'll call this \textit{exploring the program design space}. The first procedure we think of might work just fine, but there are bound to be options and we should consider how those options compare to our first idea.

To find procedures we'll start by thinking big and work our way down to details. Everything that happens in this program clearly happens inside the loop. So we need a sequence of procedures that carry out the different steps of the loop. This is what is typically meant by \textit{top-down} thinking. At the top is the big picture. At the bottom is the micro-level view. For procedural programs in C++ that can mean \textit{main} is at the top and all its helpers\sidenote{out program libraries} are at the bottom. For top-down design, our goal is to write main first, then implement the library needed to complete the main we've written. 

The other thing we should keep in mind is that the design of this program already revolves around two state variables. In theory, every procedure we need interacts with these variables in some way shape or form. When we're looking for potential helpers for main, then we can always look for a function, mutator, input, or output procedure that works with one or both of our state variables. 

So what happens inside the loop? We can break this game down to three steps:
\begin{enumerate}
\item Display the Game State to the user
\item Get the next move from the user
\item Update the game state
\end{enumerate}
Hey! Those could each be procedures. The first is an output procedure and the second is an input procedure. The third step is neither input nor output. The most natural expression of this step is as a mutator that (potentially) modifies both state variables. This is natural because we're thinking in terms of state and the fundamental operation of state is mutation. The word ``update'' itself implies a $+=$ like operation. 

We could rethink the update as assignment ($=$) plus a function. This is \textit{exactly} how you operated in COMP160. A function is used to compute the new value for the state and basic assignment is then used to update the state. We will definitely look at this option when we implement step three, but choosing this option now means we need to break step three into two steps: update the location and update the wrapped score. Why? Functions can only return a single value and we need two values. Using a mutator we can write a procedure that takes two reference parameters and modifies them both. Alternatively, we could figure out how to use \textsc{structs} in C++. This would allow us to create a game state struct type that \textsc{encapsulated} both the location and the wrapped score. The update function would then take one of these structs by value and return one by value. Again, this is \textit{exactly} how you operated in COMP160. Rather than add C++ structs to the mix, we'll work with basic atomic variables\sidenote{one value. as opposed to compound (struct) data with multiple contained values} and write a double-mutator. 

Let's go ahead and declare and document these procedures to transliterate our ideas to C++. We'll use several namespaces to organize things. All the procedures will get put in a \textit{movegame} namespace which will act as the programs main namespace.  We'll then stick our I/O procedures in a \textit{ui} namespace which is where we'll put procedures that are clearly about the User Interface. Finally, we'll put the update procedure in a \textit{model} namespace as it's all about interacting with our \textsc{computational model} of the game state, i.e. those two variables. We'll just go ahead and stick all of this in a single library \textit{move\_lib.h}. We could split \textit{ui} and \textit{model} into two libraries, but this program is simple enough that there isn't a good reason to do so. The beginning of our library header is given in figure \ref{fig:top}.

\begin{figure}[!htbp]
\begin{lstlisting}
// in move_lib.h
namespace movegame{

	namespace ui{
		
		/**
		 * Write the board and number of wraps to the stream out
		 * @param loc the location of the player
		 * @param wrap the number of times wrapped
		 * @return none
		 * @pre 0<=loc<21 , 0<=wrap
		 * @post representation of the game state is written to the
		 *   stream out
		 */
		void displayState(std::ostream& out,
						  int loc, int wrap);

		/**
		 * Get the number of spaces to move from the player
		 * @param in the stream where user input can be found
		 * @param move the variable where the user's move is stored
		 * @return none
		 * @pre none
		 * @post the user's move (int number of steps) is read from
		 *    in
		 */						  
		void getMove(std::istream& in, int& move);		
	
	
	} // end ui

	namespace model{
	
		/**
		 * Modify the location state and wrapped score based on the 
		 *   most recent move.
		 * @param curr_loc current player location
		 * @param num_wrap number of times player has wrapped
		 * @return none
		 * @pre 0<= cur_loc < 21. 0= num_wrap. 
		 * @post curr_loc moved move spaces and num_wrap is 
		 *   incremented accordingly 
		 */
		void updateState(int& cur_loc, int& num_wrap, int move);
	}

} //end move

\end{lstlisting}
\caption{The top-level helpers for \textit{main}}
\label{fig:top}
\end{figure}

In declaring these steps as procedures we're forced to work out some program level details. For starters, we need some local state (\textit{move}) to manage user-input. Otherwise, we need to carefully consider what information each step is dependent upon. Displaying the state requires, well, all the state. Getting the new move requires that local state, but that's it. Finally, updating the state requires the state and the move, but we only need the move value, not the state itself.

We can now actually finish main! This sounds crazy but if we implement those procedures to do what we want them to do, then main should do what it needs to do. Of course \textit{until} the procedures are fully implemented, \textit{main} won't work as intended. That shouldn't stop you. Not at all. Finishing up \textit{main} like this gives you a concrete testable specification to work towards. This is a much better place to be than working towards some undetermined end point. Out procedures should all come together just like we see in figure \ref{fig:main-final}.
\begin{figure}[!htbp]
\begin{lstlisting}

int main( int argc, char* argv[] ){

	// Program State Variables
	int cur_loc{0}; // player location
	int num_wrap{0}; // number of times player wrapped
	
	while( true ){
		// write out game state
		movegame::ui::displayState(std::cout,cur_loc,num_wrap);		

		// get the next move
		int move{0}; // user's move
		movegame::ui::getMove(std::cin,move);
		
		// update the state
		movegame::model::updateState(cur_loc,num_wrap,move);		
	}

	return 0;
}
\end{lstlisting}
\caption{The complete definition of \textit{main}}
\label{fig:main-final}
\end{figure}

At this point we can just stub out the procedures and compile and run our program. It will do nothing, but now we have a complete design for main that we can work towards. Stubs for the top-level helpers can be found in figure \ref{fig:top-stubs}.

\begin{figure}[!htbp]
\begin{lstlisting}
// in move_lib.cpp

void movegame::ui::displayState(std::ostream& out,
	                            int loc, int wrap){
	return;	                            
}	       

void movegame::ui::getMove(std::istream& in, int& move){
	return;
}
                     
void movegame::model::updateState(int& cur_loc, int& num_wrap, int move){
	return;
}
\end{lstlisting}
\caption{Top-level procedure stubs}
\label{fig:top-stubs}
\end{figure}

\section{Getting the User's next Move}

\section{Display the Game State}

\section{Updating the Game State}

\end{document}


