
\section{Designing for Effect}

Let's return to our simple REPL program for \textit{isWithin}. It works. It's fine. For what we needed, we don't need to change anything. The problem is that putting all our effects in main doesn't scale.  If the input process is complex and involves a lot of validation, then we might like a procedure to abstract that away.  Similarly, reporting our results might get really involved with things like printing whole tables instead of a single value. That too should be abstracted away to a procedure.  In short, we need to know how to write procedures which have an effect. If we can do that then we could imagine a new version of our REPL program where main looks like this:
\begin{verbatim}
#include "ln7.h"
#include "ln7UI.h"

int main(int argc, char* argv[]){
  using namespace ln7UI;
  using namespace std;

  double x{0.0};
  double y{0.0};
  double r{0.0};

  while(true){
    getPoint(x,y);
    getRadius(r);
    reportResults(x,y,r,TwoD::isWithin(x,y,r));
  }

  return 0;
}
\end{verbatim}

The procedures \textit{getPoint}, \textit{getRadius}, and \textit{reportResults} are all defined in a library of UI\sidenote{user interface} procedures. They're all called strictly for producing and I/O effect. The first manages the prompt and input for the x and y values. The second does the same for the circle radius r. The final reports the results. Let's see how we can design and develop these procedures. 

\subsection{Procedures for Effect}

Thus far, we approached the design and develop procedures by doing the following:
\begin{enumerate}
\item Declare and Document the procedure
\item Stub the procedure.
\item Set clear input/output expectations by writing unit tests.
\item Complete the procedure by replacing the stub definition with a real definition.
\item Test the procedure by running the unit tests and debug as needed.
\end{enumerate}

We use basic tests for two reasons: \textit{to help us understand the expected behavior of the procedure and to help us evaluate the correctness of our implementation.} The problem we face when procedures are run for effect is that effects do not occur through the usual function input, function output mechanic.  So, we either need to write different forms of tests than what we're used to, or we need to find another way to design expected behaviors and test for correct behaviors.

\section{Procedures on State Variables}

Let's say we have a procedure called \textit{foo} which takes a double as its input. Now, let's say we also have a double variable called \textit{aDub}. How should we interpret the following function call expression?
\begin{verbatim}
foo(aDub)
\end{verbatim}
We actually have two options:
\begin{enumerate}
\item pass the value, as in treat \textit{aDub} as a \textsc{r-value}
\item pass the variable, as in treat \textit{aDub} as a \textsc{l-value}
\end{enumerate}
We call the first option, \textsc{pass-by-value}, and the second \textsc{pass-by-reference}.  C++ allows you to make this distinction for each input of a procedure. 

\subsection{Pass-by-Value}

The default behavior of C++ is \textsc{pass-by-value}. The procedures you've been working with thus far are all pass-by-value. Let's say \textit{foo} has the following signature:
\begin{verbatim}
double foo(double arg1);
\end{verbatim} 
Then the function call expression \textit{foo(aDub)} from before would initialize the variable \textit{arg1} with the current value of \textit{aDub)}. This is the essence of \textsc{pass-by-value} and is the exact same function call mechanic you're used to from BSL Racket\sidenote{\textsc{substitute} every occurrence of the variable for its value in the body of the function}. Using more technical terminology, we say that pass-by-value parameters can take, as inputs, any thing with an \textsc{r-value}. This includes both variables and literals. So, we could also make the call \textit{foo(5.0)} and the compiler would have no problem with this. 

When it comes to working with our state variables, we'll prefer \textit{pass-by-value procedures for our \textsc{accessors}}.  By copying values rather than sharing variables we can be certain that we only access and don't get tempted to mutate.   

\subsection{Pass-by-Reference}

If we truly want a procedure to act on one of our variables, then we need the \textit{l-value} of the procedure's argument to be the same as the \textit{l-value} of our variable.  Put another way, we need the function's argument to be an \textsc{alias} for our variable such that the two procedures have \textsc{shared state}.  A subtle change in the procedure's signature will cause this to happen:
\begin{verbatim}
double foo(double &arg1);
\end{verbatim}
Now, when we call \textit{foo(aDub)} the system will effectively set the \textit{l-value} of \textit{arg1} to be that of \textit{aDub} thus causing \textit{arg1} to be an \textsc{alias} to \textit{aDub}. It's important to note that this means a by-reference parameter \textit{must have an \textsc{r-value}}. This means \textit{you cannot pass in literal values for by-reference parameters, you must pass variables!}

\textsc{Pass-by-reference} is the required mechanism for \textsc{mutator} procedures. The called procedure cannot mutate a state variable without having direct access to that variable. That's what pass-by-reference accomplishes and pass-by-value does not. A systems oriented view of this new mechanic might describe this shared state as a \textit{communication channel} between the caller of the procedure and the called procedure\sidenote{the callee}. Prior to this option, we could only communicate between procedures by passing in values as input, and returning values as output. 

Why make a big deal out of this communication centric view? Well, just like BSL Racket functions, we want out C++ procedures to be as independent as possible\sidenote{this is why pass-by-value is the default}.  We can essential view them in the same way we did CLI commands.  We construct more complex programs by combining these procedures. Just like on the CLI, we sometimes need these procedures to communicate either through state\sidenote{like how cd, pwd, and ls communicate} or by handing off results of one command to the next \sidenote{like using pipes or expansions}. 

This new shared state mechanism is game-changing.  Sharing state is very powerful, but easily leads to problems. We'll try to be very careful and purposeful with pass-by-reference. Right now, we'll confine our usage of it to state mutator procedures. 

\section{Designing Mutation Procedures}

If you want a procedure to change the value stored in a variable then you need to pass it by reference. Typically, such a procedure requires no output as the desired behavior is a side-effect.\sidenote{the ``output'' is placed in the variable to be read as needed}. To declare that a procedure returns nothing, we give it the \textit{void} return type. When procedures have effects, like state mutation, then we need to clearly document the side-effect as a \textsc{post-condition} of the procedure. 

Let's think about the problem of depositing and withdrawing from our bank account. We could write two procedures, one for withdraw and one for deposit. However, it's easy enough to kill to birds with one stone and just add a negative amount when withdrawing. So, lets write a general \textit{updateBalance} procedure. First we declare and document:
\begin{verbatim}
namespace banking{

 /**
   * Update the current account balance
   * @param upVal is the update value as a double
   * @param balRef is a reference to the double balance state
   * @return none
   * @pre balRef is positive. and upVal will not overdraw the account
   *    (balRef >=0 and upVal+balRef >= 0)
   * @post balance state has increase/decreased by upVal
   */
 void updateBalance(double upVal, double &balRef);
}
\end{verbatim}
I stuck something new in there. The \textit{\@pre} tag is used to document the procedure's \textsc{pre-condition}. A \textsc{pre-condition} is an assumption the programmer makes about inputs to the procedure and sometimes the state of the system. In this case, we're assuming that the update value won't cause a negative value and that the current balance is positive. This frees us from having to check for overdraws here but probably means some other part of the system needs to do this for us. Pre-conditions and post-conditions are important parts of program correctness. They are particularly important when state enters the picture as they document state change across the system. Finally, I want to point out a stylistic convention used. Notice I used ``Ref''\sidenote{short for reference} in the name of the \textsc{alias}. This is a nice naming style that helps us remember that this thing is not just a variable, but a reference to another variable somewhere else in the system. 

Now we want to document expected behavior in the form of tests.  But wait! This procedure produces no output and can't be tested like we're used to.  No worries. We're not testing for functional output anyway, we need to test for variable mutation effect. To do this right we should initialize a variable, check it before mutation, then check it after mutation to see if the desired change has occurred. When doing this right, our tests should not be dependent on one another. This can mean doing a fair amount of resetting between tests\sidenote{gTest provides some ways of automating this reset process, but its usage involves some C++ we haven't encountered. We'll get there.}. 
\begin{verbatim}

TEST(updateBalance,deposit){
  // declare and initialize a variable
  double bal(0.0);

  bal = 0.0; //reset
  EXPECT_FLOAT_EQ(0.0,bal); //before
  banking::updateBalance(50.0,bal); //mutate
  EXPECT_FLOAT_EQ(50.0,bal); //after

  bal = 0.0; //reset
  EXPECT_FLOAT_EQ(0.0,bal); //before
  banking::updateBalance(0.0,bal); //mutate
  EXPECT_FLOAT_EQ(0.0,bal); //after

  bal = 0.0; //reset
  EXPECT_FLOAT_EQ(0.0,bal); //before
  banking::updateBalance(125.45,bal); //mutate
  EXPECT_FLOAT_EQ(125.45,bal); //after
}

TEST(updateBalance,withdraw){
  // declare and initialize a variable
  double bal(0.0);

  bal = 100.0; //reset
  EXPECT_FLOAT_EQ(100.0,bal); //before
  banking::updateBalance(-50.0,bal); //mutate
  EXPECT_FLOAT_EQ(50.0,bal); //after

  bal = 100.0; //reset
  EXPECT_FLOAT_EQ(100.0,bal); //before
  banking::updateBalance(0.0,bal); //mutate
  EXPECT_FLOAT_EQ(100.0,bal); //after

  bal = 100.0; //reset
  EXPECT_FLOAT_EQ(0.0,bal); //before
  banking::updateBalance(12.50,bal); //mutate
  EXPECT_FLOAT_EQ(87.50,bal); //after
}
\end{verbatim}
Notice that we honored the multiple purposes of the procedure\sidenote{deposit and withdraw} by grouping tests for each purpose together and not just lumping them all together in to one place. Next, you should notice that we not only tested that desired changes occurred, but also when change shouldn't occur\sidenote{when the update value is $0.0$}. We probably could have gotten away with leaving out the before tests for most of these. However, these tests make the expected behavior of the procedure crystal clear and clarity is always good. So, the time it takes to write these test is worth it.  

Next we move on to the stub.
\begin{verbatim}

void banking::updateBalance(double upVal, double &balRef){
    // upVal
	// balRef

	return;
}

\end{verbatim}
Here we tossed in the names of our variables as comments so that we remember to start working with them when we get to coding this thing. Otherwise, stubs for void return types are easy enough, just return.  In this context you can think of \textit{return} not as a command to send back a value, but to just go back to where the call happened.  

We can now compile and run out tests to verify we're setup for development. Once that's done we can go ahead and knock this thing out.
\begin{verbatim}
void banking::updateBalance(double upVal, double &balRef){
	balRef += upVal;
	return;
}
\end{verbatim}

If we generalize everything we've seen so far, we see the following templates. First the declaration and documentation:
\begin{verbatim}
namespace LIBNAME{
  /**
   * A mutator procedure for the a state variable
   * @param aVar a reference to the state variable
   * @return none
   * @pre Stuff we're assuming about inputs
   * @post The state variable has changed
   */
  void MUTATOR_NAME(IN_TYPE IN_NAME, ... , VAR_TYPE &ALIAS_NAME, ...);
}
\end{verbatim}
Notice that we prefer to list regular, by value, input parameters before the reference parameters, which can act as both input and output.

Next tests: 
\begin{verbatim}
TEST(MUTATOR_NAME,testCase){
  VAR_TYPE VAR_NAME(init_value);

  VAR_NAME = value; //reset
  EXPECT_EQ(value,VAR_NAME); //before
  MUTATOR(VAR_NAME); //mutate
  EXPECT_EQ(new_value,VAR_NAME); //after

  ...
}
\end{verbatim}


And then stubs:
\begin{verbatim}
void LIBNAME::MUTATOR_NAME(VAR_TYPE &ALIAS_NAME){
	// ALIAS_NAME	
	return;
}
\end{verbatim} 

\subsection{Access Procedures}

\textsc{Accessor} procedures aren't anything new. By using \textsc{pass-by-value} for our these procedures we can treat them exactly the same as our functional procedures. Design them according to the same guidelines we've worked with previously. 

\section{Procedures for I/O}

Procedures for output provide a new challenge. If something is in memory\sidenote{variables} or the CPU\sidenote{functions} then we can compare it to another value. But we don't have commands to tell the computer to check what it just wrote to some output device.  However, we all have two eyes and are very capable of verifying that our procedure did, in fact, produce the expected output. The key, of course, is that \textit{our procedure design process clearly and firmly established an expectation of the output.}\sidenote{the correct output is not whatever the computer wrote, it's what you intended for it to write}.

Input procedures are really just mutation procedures in disguise. So, from that perspective, we just design them with the same pattern as we did with \textsc{mutators}.  Where they differ is in testing and usage.  We'll have to get involved in testing and hit the keyboard a bit. The more subtle difference comes when we consider input procedures for some or all of our model. 

\subsection{Output Procedures}

Output procedures are often about displaying computational data in ways that tie it back to the information the user is expecting. From this perspective, they're just like your drawing function from BSL Racket universe programs. There you drew a picture of the model. Here, you'll print out a text-based message about the model. The problem is still the same though: the model is computational data, not real world information. With our banking program, the problem is that the dollar values we're tossing around aren't dollar values, they're \textit{double} values. So, when we need to report back how much interest someone will earn for their balance, we need to report that double value in a way that doesn't make the average user confused.

First things first, let's recognize that computing the interest amount is a \textsc{model} problem and we should just worry about writing a procedure to report some pre-computed value. We'll plug the two pieces together with control code later. This has the added benefit of removing any temptation to pass state variables by reference to an output procedure. Let's get started with the declaration and documentation.
\begin{verbatim}
namespace bankingUI{

  /**
   * Report the amount of interest earned to the standard output.
   * @param interestAmt is the interest earned as a double
   * @return none
   * @pre interestAmt is a valid interest value (positive)
   * @post none
   */
  void reportInterest(double interestAmt);
 
}
\end{verbatim}  

So far so good. Of course, this procedure has no return type, it's meant to  cause a write effect to the standard output. Next step in the design process is tests. Here things take a different turn.  Recall that the goal of writing tests at this point is about making the expected behavior of the procedure crystal clear in our minds and not about actual testing\sidenote{can't test what you haven't written}. What's needed now is for us to decide what the output should look like and document that for ourselves. We can still use gTest as a vehicle for this even though no strict testing will occur.

\begin{verbatim}

TEST(reportInterest,all){

   reportInterest(3.0);
   // You'll earn $3.00 in interest.
   
   reportInterest(0.25);
   // You'll earn $0.25 in interest.
   
   reportInterest(135.72);
   // You'll earn $135.72 in interest.
}

\end{verbatim}
There are not actual tests in this test case. It does, however, call our output procedure three times and give the expected output, as a comment, below each call. In doing this we get to decide exactly what we want from our procedure as well as document it for other programmers to see.\sidenote{and graders to see that you've thought about what you want this thing to do}.

Now we stub. 
\begin{verbatim}
void bankingUI::reportInterest(double inerestAmt){
	std::cout << "Stub! " << interestAmt << '\n';	
	return;
}
\end{verbatim}
For this stub, I chose to go ahead and print something and include the input value in that something. This is a good reminder that this procedure will write to standard out and that the output written is related to the input.\sidenote{do you know the exact output produced by that statement?} Now it's time to code \textit{reportInterest} out. To do so we'll need to explore some more of \textit{iostream} and the \textit{iomanip} library. The \textit{iomanip} library allows us to manipulate the way in which read and write values. 

Double values have decimal precision beyond two places. Dollar values do not. We need to inject some information in to the stream in order to tell the standard output how to write doubles. 
\begin{verbatim}
void bankingUI::reportInterest(double interestAmt){
	std::cout << "You'll earn $" << 
	    std::fixed << std::showpoint << std::precision(2) <<
	    interestAmt << " in interest\n";	
	return; 
}
\end{verbatim}
The manipulators \textit{std::fixed} and \textit{std::showpoint} actually come from \textit{iostream}. The former tells the stream that floating point values should be treated as fixed point values. Combined with \textit{std::precision(2)} from \textit{iomanip}, we get exactly two places after the decimal point. The manipulator \textit{std::showpoint} guarantees that the decimal place is always show, even when there isn't one. If we leave out the \textit{std::fixed}, then \textit{std::precision(2)} tells the stream to deal with only two digits total\sidenote{before and after the decimal place}. Leaving out \textit{std::showpoint} could mean that values like $3.0$ show up as $3$ instead.

There are other useful I/O manipulators out there, we'll check them out as needed. If you just can't wait until then check out the documentation for \textit{iostream} and \textit{iomanip}.\sidenote{look for things like setfill and setw}.

\subsection{Input Procedures}

Input procedures are just mutation procedures in disguise. Recall that input require a variable. So, if you're getting input then you're mutating a variable. The only difference is the mutation mechanism. Let's look at a procedure to initialize the balance for our banking problem. 

At first glance, you might imagine passing the balance state variable directly to our initializer procedure. This makes sense, if you completely trust your user to honor your \textsc{pre-conditions} about your model's state. What if they enter a negative balance? What if they decide to type their name instead of a dollar figure? What if they attempt some kind of code-injection attack on your software?\sidenote{\url{http://en.wikipedia.org/wiki/Code\_injection}}?  So what is a poor, paranoid programmer to do?

The answer is temporary state. First we get user input for the initial balance and stick it in a variable for safe-keeping. This is the real purpose of the input function. We can then use some \textsc{controller} procedures to error check and \textit{validate} the input. So, let's proceed with our super basic input function.
\begin{verbatim}
namespace bankingUI{

  /**
   * Get an initial balance value from the user. 
   * @param iValRef a reference to a double variable for user's value
   * @return none
   * @pre user types a number
   * @post variable referenced by iValRef contains unchecked user input
   */
	void getUserBal(double &iValRef);   
}	
\end{verbatim}
Notice that I made a point to mention that this procedure results in unchecked user input. We're also going to work on the assumption that the user type a single numerical value and not get too detailed in our input checking and validation just yet. From here on out, it's just like designing a \textsc{mutator}. Testing, however, will require you to press some keys. So we can setup before/after tests like we did with our mutator, but will need to mark as a comment what you're planning to press. Here's one example, I'll let you imagine more.
\begin{verbatim}
TEST(getUserBal,all){
 double userIn(0.0);
 
 userIn = 0.0;
 EXPECT_FLOAT_EQ(0.0,userIn);
 getUserBal(userIn); // Type 350.0
 EXPECT_FLOAT_EQ(350.0,userIn);

}
\end{verbatim}

Next we stub.
\begin{verbatim}
void bankingUI::getUserBal(double &iValRef){
	//iValRef
	return;
}
\end{verbatim}
Not much new here. Do a simple return and at least comment out the variable name as a reminder for later. At this point we can compile and run our tests to verify that we're ready to roll with development. Once we've cleaned out errors and warnings, we move on to the coding stage:
\begin{verbatim}
void bankingUI::getUserBal(double &iValRef){
	std::cout << "Please enter the initial value: ";
	std::cin >> iValRef;
	return;
}
\end{verbatim}
Hey now! There's output in that procedure. True. If you expect the user to give you input, you should \textsc{prompt} them for it. We could write an output procedure for this, but that might be a bit too far. The point wasn't to only do input operations, it was to \textit{carry out a user input task}, which should involve prompting as well. 

\section{Recap}

We covered a lot of things in these notes. Let's break the big picture stuff down.
\begin{enumerate}
\item Procedure Design Process for Effect-Based Procedures
\begin{enumerate}
\item State Mutator Procedures
\item Output Procedures
\item Input Procedures
\end{enumerate}
\item Programming Concepts
\begin{enumerate}
\item \textsc{l-values} and \textsc{r-values}
\item \textsc{pass-by-value} and \textsc{pass-by-reference} procedures
\item \textsc{Model-View-Controller} architectures
\item \textsc{data streams}
\end{enumerate}
\item C++
\begin{enumerate}
\item I/O Streams \textit{std::cout}, \textit{std::cerr}, and \textit{std::cerr}
\item Streaming I/O operators $<<$  and $>>$
\item Stream manipulators \textit{std::fixed}, \textit{std::setprecision($n$)}, and \textit{std::showpoint}
\item Variable declaration and initialization.
\item The assignment operator $=$
\end{enumerate}
\end{enumerate}
