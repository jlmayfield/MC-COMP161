\documentclass[]{tufte-handout}
\usepackage{amsmath,amssymb,amsthm,color}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{framed}
\usepackage[pdftex]{graphicx}

  
\title{COMP 161 - Lecture Notes - 08 - Strings and Objects}
\date{Spring 2014}

\begin{document} 
\maketitle

\begin{abstract}
In these notes we take a look at the world of string data in C++.  In doing so we're exposed to some basic ideas in working with object classes.
\end{abstract}

\section{Objects and Classes}

We've started to use the term \textsc{object} to refer to some of the data in or programs, so let's be sure we have a clear sense of what it means.  In the most general sense, an object is a value in memory. We often refer to variables as objects because a variable is a named and typed piece of memory. For example, if we initialize the following variables,
\begin{verbatim}
int x{0};
double pi{3.14};
char let{'x'};
bool isOK{false};
\end{verbatim} 
Then we've introduced four objects to our program: the integer object \textit{x}, the double \textit{pi}, the character \textit{let}, and the boolean \textit{isOk}.  We didn't refer to these as objects at first because their types are fundamental and it's just as easy to think of them strictly in terms of their types.  

In the last set of notes we learned about some non-primitive types: \textit{istringstream}, \textit{ostream}, and \textit{istream}.  In particular we worked with a few pre-defined objects-- \textit{cout}, \textit{cin}, and \textit{cerr}-- and initialized some \textit{istringstream} objects of our own. Using the blanket term \textit{object} for this data lets us ignore the underlying complexity of the value. It's not the least be clear what an \textit{istringstream} looks like. More importantly, \textit{we don't need to know what, exactly, it looks like}. We simply need to know how to work with it though operators and procedures. 

When we're talking about types that are not built-in, types that are defined in libraries, types like \textit{ostream}, \textit{istream}, and \textit{istringstream}, then we refer to the type as a \textsc{class}.  Put another way, a \textsc{class} is synonym for \textsc{type} where calling a type a class implies that the type is user-defined.  The term object then gets used to refer to instances of that class, or values of a class in memory. 

From the users perspective\sidenote{program with the class as opposed to program the class}, working with classes is typically about working with procedures for a few general tasks:
\begin{itemize}
\item \textsc{Constructors} allow you to build objects from that class
\item \textsc{Selectors} allow you to access some or all of the data within an object
\item \textsc{Mutators} allow you to modify some or all of the data within an object 
\item \textsc{Queries} allow you to learn something about the object and its state
\end{itemize} 
Many of the procedures we'll work with are designed as a part of the class definition itself and are called differently than the usual procedure. We'll often refer to these procedures as \textsc{class methods}, or just methods. As we explore the C++ string class, you'll see all of these at work. 

\section{Strings}

A \textsc{string} is a sequence of characters. In every language I know of, string literals are written as characters in double quotes. Like this:
\begin{verbatim}
"I am a string"
"  so am I "
"12345"
\end{verbatim}

In C++, we must learn to navigate two types for string data. One is primitive, built-in and is the type associated with string literals. The other is a string class that has way more batteries included. Thus, or usual problem is we almost always start with some kind of built-in string value when what we want is a string class object. 

\subsection{C-Strings: char*}

The C-String type is unavoidable because any time you type a string literal\sidenote{characters in double quotes} the compiler sees it as a C-String value-- you can't express a string value in your program without stepping on the C-String type. The type annotation for C-Strings is \textit{char*}.  Anytime you see this type, you're dealing with C-Strings. The name C-String comes from the fact that these values are handled in exactly the same manner as string data in the C programming language. In fact, it's also the way you tend to manage strings in assembly language as well.  

Until we have a reason to do otherwise, we'll avoid directly working with C-Strings like the plague. It's not that there's anything wrong with them really, it's just that we have other libraries that make doing interesting things with strings much easier than if we stayed with raw C-Strings. We saw this with our CLI based program in the previous lecture notes. The strings coming from the CLI are C-Strings. We immediately fed them to \textit{istringstream} objects as initial values. That library then took care of reading the character sequence as if it were a double. 

\subsection{The C++ \textit{string} Class}

Our preferred string type is the \textit{std::string} class as defined in the string library\sidenote{ http://www.cplusplus.com/reference/string/string/}.  We can initialize string variables from string literals:
\begin{verbatim}
string str{"hello"};
string ing{" world!"};
\end{verbatim}
Occasionally we want to have a string object independent of an actual variable. This is very useful in testing for example. To do this we use a standard constructor form where the class name is followed by a set of parenthesis with the value inside them.  Here we see this in the context of some tests that examine the values of our previously declared string variables:
\begin{verbatim}
EXPECT_EQ(string("hello"),str);
EXPECT_EQ(string(" world!"),ing);
\end{verbatim}

We can, in fact, use gTest's \textit{EXPECT\_EQ} test on C++ string data because the class definition includes a definition for string equality. What we cannot do, is compare C++ strings to C-Strings. These tests will give you nothing but compiler errors:
\begin{verbatim}
EXPECT_EQ("hello",str);
EXPECT_EQ(" world!",ing);
\end{verbatim}
As far as the machine is concerned, a C-String, the expected value, and a C++ string object's value, the actual value, are not the same thing. This is subtle, annoying, and will cause you lots of headaches if you don't internalize this ASAP. Logically, we know they're the same. This stupid box we're programming doesn't know the difference a priori.

It is sometimes useful to get the C-String version of a string object. To do this we can use a class method. Let's see this at work and then talk about what we're seeing. Here's the same tests as before but now we're comparing C-Strings using gTest's \textit{EXPECT\_STREQ}.
\begin{verbatim}
EXPECT_STREQ("hello",str.c_str());
EXPECT_STREQ(" world!",ing.c_str());
\end{verbatim}



\section{String Streams}
\end{document}